<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Email Snipper</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f9fafb; }
    .container { max-width: 1280px; margin: 0 auto; padding: 2rem; }
    .header { margin-bottom: 2rem; }
    .title { font-size: 1.875rem; font-weight: bold; color: #111827; margin-bottom: 0.5rem; }
    .subtitle { color: #6b7280; }
    .card { background: white; border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 2rem; }
    #upload-screen .card { border: 3px dashed #d1d5db; }
    .upload-area { display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; padding: 2rem; transition: all 0.3s; }
    .upload-area.drag-over { background: #eff6ff; border-color: #3b82f6; transform: scale(1.02); }
    .upload-icon { width: 96px; height: 96px; background: #dbeafe; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 1rem; }
    .upload-icon svg { width: 48px; height: 48px; color: #2563eb; }
    .upload-title { font-size: 1.25rem; font-weight: 500; color: #111827; margin-bottom: 0.5rem; }
    .upload-subtitle { font-size: 0.875rem; color: #9ca3af; }
    .grid { display: grid; gap: 1.5rem; grid-template-columns: 2fr 1fr; }
    @media (max-width: 1024px) { .grid { grid-template-columns: 1fr; } }
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-between { justify-content: space-between; }
    .gap-2 { gap: 0.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mt-4 { margin-top: 1rem; }
    .p-6 { padding: 1.5rem; }
    .btn { padding: 0.5rem 1rem; font-size: 0.875rem; border-radius: 0.5rem; border: none; cursor: pointer; font-weight: 500; transition: all 0.2s; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn:hover { opacity: 0.9; }
    .btn-primary { background: #2563eb; color: white; }
    .btn-blue { background: #3b82f6; color: white; }
    .btn-light-blue { background: #e0f2fe; color: #0369a1; border: 1px solid #bae6fd; }
    .btn-light-blue:hover { background: #bae6fd; opacity: 1; }
    .btn-amber { background: #f59e0b; color: white; }
    .btn-green { background: #16a34a; color: white; }
    .btn-gray { background: #f3f4f6; color: #374151; border: 1px solid #e5e7eb; }
    .btn-gray:hover { background: #e5e7eb; opacity: 1; }
    .btn-white { background: white; color: #374151; border: 1px solid #e5e7eb; }
    .btn-white:hover { background: #f9fafb; opacity: 1; }
    .btn-red { background: #dc2626; color: white; }
    .btn-sm { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
    .section-title { font-size: 1.125rem; font-weight: 600; color: #111827; }
    .text-sm { font-size: 0.875rem; color: #4b5563; }
    .text-xs { font-size: 0.75rem; }
    .text-gray-500 { color: #6b7280; }
    .text-gray-400 { color: #9ca3af; }
    .canvas-container { border: 2px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; background: #f3f4f6; cursor: default; transition: opacity 0.2s; display: flex; justify-content: center; align-items: center; }
    #canvas { display: block; }
    .snippet-list { max-height: 600px; overflow-y: auto; }
    .snippet-item { border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.75rem; transition: border-color 0.2s; margin-bottom: 0.75rem; }
    .snippet-item:hover { border-color: #93c5fd; }
    .info-box { background: #eff6ff; border-radius: 0.5rem; padding: 1rem; }
    .info-button { background: transparent; border: none; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #9ca3af; transition: all 0.2s; padding: 0; }
    .info-button:hover { color: #3b82f6; transform: scale(1.15); }
    .info-button-small { background: transparent; border: none; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; padding: 0; }
    .info-button-yellow { color: #d97706; }
    .info-button-yellow:hover { color: #f59e0b; transform: scale(1.2); }
    .info-popup { position: absolute; left: 0; top: 100%; margin-top: 0.5rem; background: #fffbeb; border: 2px solid #fbbf24; border-radius: 0.5rem; padding: 0.75rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 100; min-width: 280px; max-width: 320px; animation: popupSlide 0.2s ease-out; }
    @keyframes popupSlide { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .info-panel { background: #eff6ff; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; animation: slideDown 0.3s ease-out; }
    @keyframes slideDown { from { opacity: 0; max-height: 0; padding: 0 1rem; } to { opacity: 1; max-height: 500px; padding: 1rem; } }
    .info-title { font-weight: 500; color: #1e3a8a; font-size: 0.875rem; margin-bottom: 0.5rem; }
    .info-list { font-size: 0.75rem; color: #1e40af; list-style: none; }
    .info-list li { margin-bottom: 0.25rem; }
    .empty-state { text-align: center; padding: 3rem 0; }
    .empty-icon { width: 64px; height: 64px; background: #f3f4f6; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 0.75rem; }
    .empty-icon svg { width: 32px; height: 32px; color: #9ca3af; }
    input[type="file"] { display: none; }
    .hidden { display: none; }
    #upload-screen { display: block; }
    #editor-screen { display: none; }
    .exclusion-controls { background: #fffbeb; border: 1px solid #fde68a; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .exclusion-title { font-weight: 600; color: #92400e; margin-bottom: 0.75rem; font-size: 0.875rem; }
    .input-group { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    .input-group input { padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; width: 100px; }
    .input-group label { font-size: 0.875rem; color: #374151; }
    .compression-controls { background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 0.5rem; padding: 1rem; margin-top: 1.5rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .compression-title { font-weight: 600; color: #1e40af; margin-bottom: 0.75rem; font-size: 0.875rem; }
    .slider-container { display: flex; flex-direction: column; gap: 0.5rem; }
    .slider-container input[type="range"] { width: 100%; }
    .progress-dots { display: flex; justify-content: center; gap: 1rem; }
    .progress-step { display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: #9ca3af; transition: all 0.3s; }
    .progress-step.active { color: #3b82f6; font-weight: 600; }
    .progress-step.complete { color: #10b981; }
    .progress-dot { width: 24px; height: 24px; border-radius: 50%; background: #e5e7eb; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.75rem; transition: all 0.3s; }
    .progress-step.active .progress-dot { background: #3b82f6; color: white; }
    .progress-step.complete .progress-dot { background: #10b981; color: white; }
    .zoom-controls { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem; justify-content: center; }
    .zoom-btn { width: 32px; height: 32px; border-radius: 0.375rem; border: 1px solid #d1d5db; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: 600; transition: all 0.2s; }
    .zoom-btn:hover { background: #f3f4f6; }
    .zoom-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .zoom-level { font-size: 0.75rem; color: #6b7280; min-width: 50px; text-align: center; }
    .quality-label { font-size: 0.75rem; color: #1e40af; display: flex; justify-content: space-between; }
    .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
    @media (max-width: 768px) { .controls-grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="title">Quick Email Snipper</h1>
    </div>

    <!-- Upload Screen -->
    <div id="upload-screen">
      <p class="subtitle" style="text-align: center; margin-bottom: 2rem;">Upload your email design and create downloadable snippets</p>
      <div class="card">
        <label class="upload-area" for="file-input">
          <div class="upload-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
          </div>
          <span class="upload-title">Upload Email Design</span>
          <span class="upload-subtitle">Click to browse or drag and drop</span>
          <input type="file" id="file-input" accept="image/*">
        </label>
      </div>
    </div>

    <!-- Editor Screen -->
    <div id="editor-screen" class="grid">
      <div>
        <!-- Progress Indicator -->
        <div class="progress-dots" style="background: white; border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 0.75rem 1rem; margin-bottom: 1.5rem;">
          <div class="progress-step complete">
            <div class="progress-dot">‚úì</div>
            <span>Upload</span>
          </div>
          <div class="progress-step" id="progress-footer">
            <div class="progress-dot">‚ë°</div>
            <span>Set Footer</span>
          </div>
          <div class="progress-step" id="progress-split">
            <div class="progress-dot">‚ë¢</div>
            <span>Split</span>
          </div>
          <div class="progress-step" id="progress-download">
            <div class="progress-dot">‚ë£</div>
            <span>Download</span>
          </div>
        </div>
        
        <div class="card p-6">
          <div class="flex items-center justify-between mb-4">
            <h2 class="section-title">Email Design</h2>
            <div class="flex gap-2">
              <button id="undo-btn" class="btn btn-gray" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
              <button id="redo-btn" class="btn btn-gray" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
              <label class="btn btn-primary" for="new-image">New Image</label>
              <input type="file" id="new-image" accept="image/*">
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
            <div class="exclusion-controls">
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; position: relative;">
                <div class="exclusion-title" style="margin-bottom: 0;">‚ö†Ô∏è Exclude Footer Section</div>
                <button id="footer-info-btn" class="info-button-small info-button-yellow" title="Click for help">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M12 16v-4"></path>
                    <circle cx="12" cy="8" r="0.5" fill="currentColor"></circle>
                  </svg>
                </button>
                <div id="footer-info-popup" class="info-popup" style="display: none;">
                  <div style="font-weight: 600; margin-bottom: 0.5rem; color: #92400e;">üí° How to Exclude Footer</div>
                  <ol style="margin: 0; padding-left: 1.25rem; font-size: 0.75rem; line-height: 1.5;">
                    <li>Click "Detect Boundary Lines" to scan your email</li>
                    <li>Green dashed lines will appear at color boundaries</li>
                    <li>Click the line right above your footer section</li>
                    <li>The selected area will be excluded from snippets</li>
                  </ol>
                </div>
              </div>
              <button id="detect-lines" class="btn" style="width: 100%; margin-bottom: 0.75rem; transition: all 0.3s; background: #fef3c7; color: #92400e; border: 1px solid #fde68a;">
                Detect Boundary Lines
              </button>
              <div class="input-group">
                <label for="exclude-height">Selected:</label>
                <input type="number" id="exclude-height" value="0" min="0" step="10" style="background: white;">
                <span class="text-sm">px</span>
              </div>
            </div>
            
            <div style="background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
              <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.75rem; font-size: 0.875rem;">‚úÇÔ∏è Split Email</div>
              <div class="input-group" style="margin-bottom: 0.75rem;">
                <label for="split-number" style="font-size: 0.875rem; color: #1e40af;">Split into:</label>
                <select id="split-number" style="padding: 0.5rem; border: 1px solid #bfdbfe; border-radius: 0.375rem; width: 80px; font-weight: 500; background: white;">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3" selected>3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                  <option value="6">6</option>
                  <option value="7">7</option>
                  <option value="8">8</option>
                  <option value="9">9</option>
                  <option value="10">10</option>
                  <option value="11">11</option>
                  <option value="12">12</option>
                </select>
                <span class="text-sm" style="color: #1e40af;">sections</span>
              </div>
              <div style="display: flex; gap: 0.5rem;">
                <button id="split-button" class="btn btn-blue" style="flex: 1;">Split</button>
                <button id="clear-all" class="btn btn-white" style="flex: 1;">Clear</button>
              </div>
            </div>
          </div>
          
          <!-- Zoom Controls -->
          <div class="zoom-controls">
            <button id="zoom-out" class="zoom-btn">‚àí</button>
            <span class="zoom-level" id="zoom-display">100%</span>
            <button id="zoom-in" class="zoom-btn">+</button>
          </div>
          
          <div id="canvas-wrapper" class="canvas-container" style="margin-bottom: 1.5rem;">
            <canvas id="canvas"></canvas>
          </div>
        </div>
      </div>

      <div>
        <div class="card p-6">
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-2">
              <h2 class="section-title">Snippets (<span id="snippet-count">0</span>)</h2>
              <button id="info-toggle" class="info-button" title="How to use">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <path d="M12 16v-4"></path>
                  <circle cx="12" cy="8" r="0.5" fill="currentColor"></circle>
                </svg>
              </button>
            </div>
            <button id="download-all" class="btn btn-green hidden">Download All</button>
          </div>
          
          <div id="info-panel" class="info-panel" style="display: none;">
            <h3 class="info-title">How to use:</h3>
            <ul class="info-list">
              <li>‚Ä¢ Click "Detect Boundary Lines" and select footer line</li>
              <li>‚Ä¢ Choose sections (1-12) and click "Split"</li>
              <li>‚Ä¢ Use "‚Üî Split into 2/3" for product grids</li>
              <li>‚Ä¢ Split snippets appear grouped (can't be re-split)</li>
              <li>‚Ä¢ Drag edges to fine-tune boundaries</li>
              <li>‚Ä¢ Use Undo/Redo buttons or Ctrl+Z / Ctrl+Y</li>
              <li>‚Ä¢ Adjust compression (90% = TinyPNG-style)</li>
            </ul>
          </div>
          
          <div id="snippet-list"></div>
        </div>

        <div class="compression-controls">
          <div class="compression-title">üóúÔ∏è Compression Settings</div>
          <div class="slider-container">
            <div class="quality-label">
              <span>Quality: <span id="quality-value">90</span>%</span>
              <span id="compression-estimate">~50-70% smaller</span>
            </div>
            <input type="range" id="compression-quality" min="60" max="100" value="90" step="5">
            <div class="input-group" style="margin-top: 0.5rem;">
              <label style="font-size: 0.75rem; color: #1e40af;">
                <input type="checkbox" id="use-compression" checked> 
                Enable compression (saves as .jpg)
              </label>
            </div>
          </div>
          <p class="text-xs" style="color: #1e40af; margin-top: 0.5rem;">üí° 90% quality is ideal for email. Uncheck for transparent PNG.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    let image = null;
    let snippets = [];
    let isDrawing = false;
    let startPoint = null;
    let currentRect = null;
    let imageScale = 1;
    let zoomLevel = 1; // User-controlled zoom (0.7, 0.85, 1, 1.15, 1.3)
    let highlightedSnippet = -1; // Index of snippet to highlight
    let excludeHeight = 0;
    let isDraggingEdge = false;
    let draggedSnippetIndex = -1;
    let dragEdgeType = null; // 'top' or 'bottom'
    let dragStartY = 0;
    let isCanvasUpdateScheduled = false; // Throttle canvas updates during drag
    let compressionQuality = 0.90;
    let useCompression = true;
    let detectedLines = []; // Array of Y positions for detected boundaries
    let selectedLine = null; // Currently selected boundary line
    
    // Undo/Redo system
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 50;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uploadScreen = document.getElementById('upload-screen');
    const editorScreen = document.getElementById('editor-screen');
    const snippetList = document.getElementById('snippet-list');
    const snippetCount = document.getElementById('snippet-count');
    const downloadAllBtn = document.getElementById('download-all');
    const excludeInput = document.getElementById('exclude-height');
    const compressionSlider = document.getElementById('compression-quality');
    const compressionCheckbox = document.getElementById('use-compression');
    const qualityValueDisplay = document.getElementById('quality-value');
    const splitNumberSelect = document.getElementById('split-number');
    const splitButton = document.getElementById('split-button');
    const clearAllButton = document.getElementById('clear-all');
    const detectLinesBtn = document.getElementById('detect-lines');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomDisplay = document.getElementById('zoom-display');
    const infoToggle = document.getElementById('info-toggle');
    const infoPanel = document.getElementById('info-panel');

    document.getElementById('file-input').addEventListener('change', handleImageUpload);
    document.getElementById('new-image').addEventListener('change', handleImageUpload);
    splitButton.addEventListener('click', () => autoSplit(parseInt(splitNumberSelect.value)));
    clearAllButton.addEventListener('click', clearAll);
    document.getElementById('download-all').addEventListener('click', downloadAll);
    excludeInput.addEventListener('input', handleExcludeChange);
    compressionSlider.addEventListener('input', handleCompressionChange);
    compressionCheckbox.addEventListener('change', handleCompressionToggle);
    detectLinesBtn.addEventListener('click', detectBoundaryLines);
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    zoomInBtn.addEventListener('click', zoomIn);
    zoomOutBtn.addEventListener('click', zoomOut);
    
    // Info panel toggle
    infoToggle.addEventListener('click', function() {
      if (infoPanel.style.display === 'none') {
        infoPanel.style.display = 'block';
      } else {
        infoPanel.style.display = 'none';
      }
    });

    // Footer info popup toggle
    const footerInfoBtn = document.getElementById('footer-info-btn');
    const footerInfoPopup = document.getElementById('footer-info-popup');
    
    footerInfoBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (footerInfoPopup.style.display === 'none') {
        footerInfoPopup.style.display = 'block';
      } else {
        footerInfoPopup.style.display = 'none';
      }
    });
    
    // Close popup when clicking outside
    document.addEventListener('click', function(e) {
      if (!footerInfoPopup.contains(e.target) && e.target !== footerInfoBtn) {
        footerInfoPopup.style.display = 'none';
      }
    });

    // Initialize drag and drop
    initDragAndDrop();

    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', function(e) {
      // Ctrl+Z or Cmd+Z for undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
    });

    // Drag and Drop functionality
    function initDragAndDrop() {
      const uploadArea = document.querySelector('.upload-area');
      const canvasWrapper = document.getElementById('canvas-wrapper');
      
      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, preventDefaults, false);
      });
      
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Upload screen drag and drop
      ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
          uploadArea.classList.add('drag-over');
        }, false);
      });
      
      ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
          uploadArea.classList.remove('drag-over');
        }, false);
      });
      
      uploadArea.addEventListener('drop', handleDrop, false);
      
      // Canvas area drag and drop (for replacing image)
      if (canvasWrapper) {
        ['dragenter', 'dragover'].forEach(eventName => {
          canvasWrapper.addEventListener(eventName, () => {
            canvasWrapper.style.opacity = '0.5';
          }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
          canvasWrapper.addEventListener(eventName, () => {
            canvasWrapper.style.opacity = '1';
          }, false);
        });
        
        canvasWrapper.addEventListener('drop', handleDrop, false);
      }
    }
    
    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (files.length > 0) {
        const file = files[0];
        if (file.type.startsWith('image/')) {
          processImageFile(file);
        } else {
          alert('Please drop an image file (PNG, JPG, etc.)');
        }
      }
    }
    
    function processImageFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          image = img;
          snippets = [];
          currentRect = null;
          excludeHeight = 0;
          excludeInput.value = 0;
          zoomLevel = 1; // Reset zoom
          highlightedSnippet = -1; // Reset highlight
          
          // Initialize history with clean state
          history = [];
          historyIndex = -1;
          saveState();
          
          uploadScreen.style.display = 'none';
          editorScreen.style.display = 'grid';
          updateCanvas();
          updateSnippetList();
          updateDetectButtonState();
          updateZoomDisplay();
          updateProgress();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);

    // Undo/Redo system functions
    function saveState() {
      // Only save if there are actual changes (image loaded)
      if (!image) return;
      
      // Create a deep copy of current state
      const state = {
        snippets: JSON.parse(JSON.stringify(snippets)),
        excludeHeight: excludeHeight
      };
      
      // Remove any future history if we're not at the end
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      
      // Add new state
      history.push(state);
      
      // Limit history size
      if (history.length > MAX_HISTORY) {
        history.shift();
      } else {
        historyIndex++;
      }
      
      updateUndoRedoButtons();
    }

    function undo() {
      if (historyIndex <= 0) {
        console.log('Nothing to undo');
        return;
      }
      
      historyIndex--;
      restoreState(history[historyIndex]);
      updateUndoRedoButtons();
    }

    function redo() {
      if (historyIndex >= history.length - 1) {
        console.log('Nothing to redo');
        return;
      }
      
      historyIndex++;
      restoreState(history[historyIndex]);
      updateUndoRedoButtons();
    }

    function zoomIn() {
      const levels = [0.7, 0.85, 1, 1.15, 1.3];
      const currentIndex = levels.indexOf(zoomLevel);
      if (currentIndex < levels.length - 1) {
        zoomLevel = levels[currentIndex + 1];
        updateCanvas();
        updateZoomDisplay();
      }
    }

    function zoomOut() {
      const levels = [0.7, 0.85, 1, 1.15, 1.3];
      const currentIndex = levels.indexOf(zoomLevel);
      if (currentIndex > 0) {
        zoomLevel = levels[currentIndex - 1];
        updateCanvas();
        updateZoomDisplay();
      }
    }

    function updateZoomDisplay() {
      zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
      zoomInBtn.disabled = zoomLevel >= 1.3;
      zoomOutBtn.disabled = zoomLevel <= 0.7;
    }

    function restoreState(state) {
      snippets = JSON.parse(JSON.stringify(state.snippets));
      excludeHeight = state.excludeHeight;
      excludeInput.value = excludeHeight;
      updateCanvas();
      updateSnippetList();
      updateDetectButtonState();
      updateProgress();
    }

    function updateUndoRedoButtons() {
      if (undoBtn && redoBtn) {
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= history.length - 1;
      }
    }

    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (file && file.type.startsWith('image/')) {
        processImageFile(file);
      }
    }

    function handleExcludeChange(e) {
      excludeHeight = parseInt(e.target.value) || 0;
      updateCanvas();
      updateDetectButtonState();
      updateProgress();
      saveState();
    }

    function updateDetectButtonState() {
      const detectBtn = document.getElementById('detect-lines');
      if (excludeHeight > 0) {
        // Fade out when boundary is selected
        detectBtn.style.opacity = '0.5';
        detectBtn.style.background = '#f9fafb';
        detectBtn.style.color = '#9ca3af';
        detectBtn.style.border = '1px solid #e5e7eb';
      } else {
        // Normal state - soft amber color
        detectBtn.style.opacity = '1';
        detectBtn.style.background = '#fef3c7';
        detectBtn.style.color = '#92400e';
        detectBtn.style.border = '1px solid #fde68a';
      }
    }

    function updateProgress() {
      const footerStep = document.getElementById('progress-footer');
      const splitStep = document.getElementById('progress-split');
      const downloadStep = document.getElementById('progress-download');
      
      // Reset all
      footerStep.classList.remove('active', 'complete');
      splitStep.classList.remove('active', 'complete');
      downloadStep.classList.remove('active', 'complete');
      
      // Update based on state
      if (excludeHeight > 0) {
        footerStep.classList.add('complete');
        footerStep.querySelector('.progress-dot').textContent = '‚úì';
        
        if (snippets.length > 0) {
          splitStep.classList.add('complete');
          splitStep.querySelector('.progress-dot').textContent = '‚úì';
          downloadStep.classList.add('active');
        } else {
          splitStep.classList.add('active');
        }
      } else {
        footerStep.classList.add('active');
      }
    }

    function handleCompressionChange(e) {
      compressionQuality = parseInt(e.target.value) / 100;
      qualityValueDisplay.textContent = e.target.value;
      
      // Update compression estimate based on quality
      const estimate = compressionQuality >= 0.95 ? '~20-30% smaller' :
                      compressionQuality >= 0.85 ? '~50-70% smaller' :
                      compressionQuality >= 0.75 ? '~60-75% smaller' :
                      '~70-80% smaller';
      document.getElementById('compression-estimate').textContent = estimate;
    }

    function handleCompressionToggle(e) {
      useCompression = e.target.checked;
    }

    function detectBoundaryLines() {
      if (!image) return;
      
      detectedLines = [];
      selectedLine = null;
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = image.width;
      tempCanvas.height = image.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(image, 0, 0);
      
      const boundaries = [];
      const scanStep = 1; // Scan EVERY row for maximum precision
      const minSpacing = 40; // Allow closer lines
      
      // Scan from 5% to 98% of image height
      for (let y = Math.floor(image.height * 0.05); y < Math.floor(image.height * 0.98); y += scanStep) {
        // Get two consecutive rows
        const currentRow = tempCtx.getImageData(0, y, image.width, 1);
        const nextRow = tempCtx.getImageData(0, Math.min(y + 1, image.height - 1), image.width, 1);
        
        let totalColorDiff = 0;
        let significantChanges = 0;
        let anyChanges = 0;
        let totalPixels = 0;
        
        // Sample every 2 pixels across the width for speed
        for (let x = 0; x < image.width; x += 2) {
          const i = x * 4;
          
          // Get RGB values for current row
          const r1 = currentRow.data[i];
          const g1 = currentRow.data[i + 1];
          const b1 = currentRow.data[i + 2];
          
          // Get RGB values for next row
          const r2 = nextRow.data[i];
          const g2 = nextRow.data[i + 1];
          const b2 = nextRow.data[i + 2];
          
          // Calculate total color difference
          const colorDiff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
          
          totalColorDiff += colorDiff;
          totalPixels++;
          
          // Count different thresholds
          if (colorDiff > 15) significantChanges++;
          if (colorDiff > 3) anyChanges++;
        }
        
        const avgColorDiff = totalColorDiff / totalPixels;
        const significantPercentage = significantChanges / totalPixels;
        const anyChangePercentage = anyChanges / totalPixels;
        
        // Multiple detection criteria - if ANY of these are true, it's a boundary:
        const isStrongBoundary = significantPercentage > 0.4 && avgColorDiff > 20; // Strong changes
        const isMediumBoundary = significantPercentage > 0.6 && avgColorDiff > 10; // Medium changes across width
        const isSubtleBoundary = anyChangePercentage > 0.75 && avgColorDiff > 5;   // Subtle but consistent
        
        if (isStrongBoundary || isMediumBoundary || isSubtleBoundary) {
          const strength = significantPercentage * avgColorDiff + (anyChangePercentage * 5);
          boundaries.push({ y: y, strength: strength });
        }
      }
      
      // Sort by strength
      boundaries.sort((a, b) => b.strength - a.strength);
      
      // Filter to avoid closely spaced lines
      for (const boundary of boundaries) {
        let tooClose = false;
        for (const existing of detectedLines) {
          if (Math.abs(boundary.y - existing) < minSpacing) {
            tooClose = true;
            break;
          }
        }
        if (!tooClose) {
          detectedLines.push(boundary.y);
        }
        if (detectedLines.length >= 35) break; // Show up to 35 lines
      }
      
      detectedLines.sort((a, b) => a - b);
      updateCanvas();
      
      if (detectedLines.length === 0) {
        alert('No boundary lines detected. Try manually entering a value.');
      }
    }

    function handleMouseDown(e) {
      if (!image) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / (imageScale * zoomLevel);
      const y = (e.clientY - rect.top) / (imageScale * zoomLevel);
      
      // Check if clicking on a detected boundary line
      if (detectedLines.length > 0 && snippets.length === 0) {
        const clickThreshold = 15; // Pixels from line to count as click
        for (const lineY of detectedLines) {
          if (Math.abs(y - lineY) < clickThreshold) {
            selectedLine = lineY;
            excludeHeight = image.height - lineY;
            excludeInput.value = excludeHeight;
            detectedLines = []; // Clear other lines after selection
            updateCanvas();
            updateDetectButtonState();
            updateProgress();
            saveState();
            return;
          }
        }
      }
      
      // Check if clicking near a snippet edge (within 10px)
      const edgeThreshold = 10;
      for (let i = 0; i < snippets.length; i++) {
        const snippet = snippets[i];
        
        // Check top edge
        if (Math.abs(y - snippet.y) < edgeThreshold && 
            x >= snippet.x && x <= snippet.x + snippet.width) {
          isDraggingEdge = true;
          draggedSnippetIndex = i;
          dragEdgeType = 'top';
          dragStartY = y;
          canvas.style.cursor = 'ns-resize';
          return;
        }
        
        // Check bottom edge
        if (Math.abs(y - (snippet.y + snippet.height)) < edgeThreshold && 
            x >= snippet.x && x <= snippet.x + snippet.width) {
          isDraggingEdge = true;
          draggedSnippetIndex = i;
          dragEdgeType = 'bottom';
          dragStartY = y;
          canvas.style.cursor = 'ns-resize';
          return;
        }
      }
      
      // Manual drawing disabled - only edge dragging allowed
    }

    function handleMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / (imageScale * zoomLevel);
      const y = (e.clientY - rect.top) / (imageScale * zoomLevel);
      
      // Handle edge dragging
      if (isDraggingEdge && draggedSnippetIndex >= 0) {
        const snippet = snippets[draggedSnippetIndex];
        const maxY = image.height - excludeHeight;
        
        if (dragEdgeType === 'top') {
          const newY = Math.max(0, Math.min(y, snippet.y + snippet.height - 20));
          const deltaY = newY - snippet.y;
          snippet.y = newY;
          snippet.height -= deltaY;
          
          // Also move the bottom edge of the previous snippet (if exists)
          if (draggedSnippetIndex > 0) {
            const prevSnippet = snippets[draggedSnippetIndex - 1];
            prevSnippet.height = snippet.y - prevSnippet.y;
          }
        } else if (dragEdgeType === 'bottom') {
          const newBottom = Math.max(snippet.y + 20, Math.min(y, maxY));
          snippet.height = newBottom - snippet.y;
          
          // Also move the top edge of the next snippet (if exists)
          if (draggedSnippetIndex < snippets.length - 1) {
            const nextSnippet = snippets[draggedSnippetIndex + 1];
            const oldNextY = nextSnippet.y;
            nextSnippet.y = snippet.y + snippet.height;
            nextSnippet.height = nextSnippet.height + (oldNextY - nextSnippet.y);
          }
        }
        
        updateCanvasThrottled();
        return;
      }
      
      // Check if hovering over detected boundary lines
      if (detectedLines.length > 0 && snippets.length === 0) {
        const hoverThreshold = 15;
        let overLine = false;
        for (const lineY of detectedLines) {
          if (Math.abs(y - lineY) < hoverThreshold) {
            canvas.style.cursor = 'pointer';
            overLine = true;
            break;
          }
        }
        if (!overLine) {
          canvas.style.cursor = 'default';
        }
        return;
      }
      
      // Update cursor when hovering over edges
      if (!isDraggingEdge) {
        const edgeThreshold = 10;
        let overEdge = false;
        
        for (let i = 0; i < snippets.length; i++) {
          const snippet = snippets[i];
          
          if ((Math.abs(y - snippet.y) < edgeThreshold || 
               Math.abs(y - (snippet.y + snippet.height)) < edgeThreshold) &&
              x >= snippet.x && x <= snippet.x + snippet.width) {
            canvas.style.cursor = 'ns-resize';
            overEdge = true;
            break;
          }
        }
        
        if (!overEdge) {
          canvas.style.cursor = 'default';
        }
      }
    }

    function handleMouseUp() {
      // Handle edge dragging completion
      if (isDraggingEdge) {
        isDraggingEdge = false;
        draggedSnippetIndex = -1;
        dragEdgeType = null;
        canvas.style.cursor = 'default';
        updateSnippetList();
        updateCanvas();
        saveState();
        return;
      }
    }

    function autoSplit(numSections) {
      if (!image) return;
      snippets = [];
      const availableHeight = image.height - excludeHeight;
      const sectionHeight = availableHeight / numSections;
      for (let i = 0; i < numSections; i++) {
        snippets.push({
          id: Date.now() + i,
          x: 0,
          y: i * sectionHeight,
          width: image.width,
          height: sectionHeight
        });
      }
      updateCanvas();
      updateSnippetList();
      updateProgress();
      saveState();
    }

    function clearAll() {
      snippets = [];
      currentRect = null;
      highlightedSnippet = -1; // Reset highlight
      updateCanvas();
      updateSnippetList();
      updateProgress();
      saveState();
    }

    function updateCanvasThrottled() {
      if (isCanvasUpdateScheduled) return;
      isCanvasUpdateScheduled = true;
      requestAnimationFrame(() => {
        updateCanvas();
        isCanvasUpdateScheduled = false;
      });
    }

    function updateCanvas() {
      if (!image) return;

      const maxWidth = document.getElementById('canvas-wrapper').clientWidth - 120;
      imageScale = Math.min(1, maxWidth / image.width);

      canvas.width = image.width;
      canvas.height = image.height;
      canvas.style.width = `${image.width * imageScale * zoomLevel}px`;
      canvas.style.height = `${image.height * imageScale * zoomLevel}px`;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);

      // Draw exclusion zone overlay
      if (excludeHeight > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, image.height - excludeHeight, image.width, excludeHeight);
        
        // Draw border line
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(0, image.height - excludeHeight);
        ctx.lineTo(image.width, image.height - excludeHeight);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw label
        ctx.fillStyle = '#f59e0b';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('EXCLUDED FOOTER', 20, image.height - excludeHeight / 2);
      }

      // Draw detected boundary lines (when no snippets created yet)
      if (detectedLines.length > 0 && snippets.length === 0) {
        detectedLines.forEach((lineY, index) => {
          ctx.strokeStyle = '#10b981'; // Green for clickable lines
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(0, lineY);
          ctx.lineTo(image.width, lineY);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Draw line number
          ctx.fillStyle = '#10b981';
          ctx.font = 'bold 16px Arial';
          ctx.fillText(`${index + 1}`, 10, lineY - 5);
        });
        
        // Add instruction text
        ctx.fillStyle = '#10b981';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('Click on the line above your footer', 20, 40);
      }

      // Draw existing snippets
      ctx.strokeStyle = '#3B82F6';
      ctx.lineWidth = 3;
      snippets.forEach((snippet, index) => {
        // Check if this snippet is highlighted
        const isHighlighted = highlightedSnippet === index;
        
        if (isHighlighted) {
          // Draw glowing highlight
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 8;
          ctx.shadowColor = '#f59e0b';
          ctx.shadowBlur = 15;
          ctx.strokeRect(snippet.x, snippet.y, snippet.width, snippet.height);
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'rgba(245, 158, 11, 0.15)';
          ctx.fillRect(snippet.x, snippet.y, snippet.width, snippet.height);
          ctx.lineWidth = 3;
        } else {
          // Normal snippet drawing
          ctx.strokeStyle = '#3B82F6';
          ctx.strokeRect(snippet.x, snippet.y, snippet.width, snippet.height);
          ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
          ctx.fillRect(snippet.x, snippet.y, snippet.width, snippet.height);
        }
        
        // Draw thicker edge lines to indicate draggable areas
        ctx.lineWidth = 6;
        
        // Top edge - only draw if it's the first snippet or not connected to previous
        if (index === 0 || snippets[index - 1].y + snippets[index - 1].height !== snippet.y) {
          ctx.strokeStyle = '#3B82F6';
          ctx.beginPath();
          ctx.moveTo(snippet.x, snippet.y);
          ctx.lineTo(snippet.x + snippet.width, snippet.y);
          ctx.stroke();
        } else {
          // Draw connected edge indicator
          ctx.strokeStyle = '#10B981'; // Green for connected edges
          ctx.beginPath();
          ctx.moveTo(snippet.x, snippet.y);
          ctx.lineTo(snippet.x + snippet.width, snippet.y);
          ctx.stroke();
        }
        
        // Bottom edge - use green if connected to next snippet
        if (index < snippets.length - 1 && snippet.y + snippet.height === snippets[index + 1].y) {
          ctx.strokeStyle = '#10B981'; // Green for connected edges
        } else {
          ctx.strokeStyle = '#3B82F6';
        }
        ctx.beginPath();
        ctx.moveTo(snippet.x, snippet.y + snippet.height);
        ctx.lineTo(snippet.x + snippet.width, snippet.y + snippet.height);
        ctx.stroke();
        
        // Draw left edge divider if snippet is side-by-side with another
        if (index > 0 && snippets[index - 1].y === snippet.y && 
            snippets[index - 1].x + snippets[index - 1].width === snippet.x) {
          ctx.strokeStyle = '#6b7280'; // Gray for horizontal splits
          ctx.lineWidth = 4;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(snippet.x, snippet.y);
          ctx.lineTo(snippet.x, snippet.y + snippet.height);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw label
        ctx.fillStyle = '#3B82F6';
        ctx.font = '20px Arial';
        if (snippet.parentId) {
          const positionShort = snippet.position === 'Left' ? 'L' : snippet.position === 'Right' ? 'R' : 'C';
          const parentNum = snippet.parentLabel.replace('Snippet ', '');
          ctx.fillText(`${parentNum}${positionShort}`, snippet.x + 10, snippet.y + 30);
        } else {
          ctx.fillText(`${index + 1}`, snippet.x + 10, snippet.y + 30);
        }
        
        // Reset line width
        ctx.lineWidth = 3;
      });
    }

    function updateSnippetList() {
      snippetCount.textContent = snippets.length;
      
      if (snippets.length === 0) {
        downloadAllBtn.classList.add('hidden');
        snippetList.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
            </div>
            <p class="text-gray-500 text-sm">No snippets created yet</p>
            <p class="text-gray-400 text-xs">Select number of sections and click "Split" to get started</p>
          </div>
        `;
      } else {
        downloadAllBtn.classList.remove('hidden');
        
        // Group snippets by parent
        const groups = [];
        let currentGroup = null;
        
        snippets.forEach((snippet, index) => {
          if (snippet.parentId) {
            // This is a child snippet
            if (!currentGroup || currentGroup.parentId !== snippet.parentId) {
              currentGroup = {
                parentId: snippet.parentId,
                parentLabel: snippet.parentLabel,
                children: []
              };
              groups.push(currentGroup);
            }
            currentGroup.children.push({ snippet, index });
          } else {
            // This is a regular snippet
            currentGroup = null;
            groups.push({ snippet, index });
          }
        });
        
        // Render grouped snippets
        snippetList.innerHTML = groups.map(group => {
          if (group.children) {
            // Render parent with children
            return `
              <div class="snippet-item" style="border: 2px solid #e5e7eb; background: #f9fafb;">
                <div class="flex items-center justify-between mb-3">
                  <div style="font-weight: 600; color: #4b5563; font-size: 0.875rem;">
                    ${group.parentLabel} (Split)
                  </div>
                  <div class="flex gap-2">
                    <button onclick="downloadGroup(${group.children[0].snippet.id})" class="btn btn-sm btn-primary" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">
                      Download All
                    </button>
                    <button onclick="deleteSnippet(${group.children[0].snippet.id})" class="btn btn-sm btn-red" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">
                      Delete Group
                    </button>
                  </div>
                </div>
                ${group.children.map(({ snippet, index }) => {
                  const isHighlighted = highlightedSnippet === index;
                  return `
                  <div onclick="highlightSnippet(${index})" style="margin-left: 1rem; padding: 0.5rem; background: white; border-radius: 0.375rem; margin-bottom: 0.5rem; cursor: pointer; ${isHighlighted ? 'border: 2px solid #3b82f6; background: #eff6ff;' : 'border: 1px solid #e5e7eb;'}">
                    <div class="flex items-center justify-between mb-2">
                      <span style="font-weight: 500; font-size: 0.875rem;">${snippet.parentLabel} - ${snippet.position}</span>
                      <button onclick="event.stopPropagation(); downloadSnippet(${index})" class="btn btn-sm btn-primary" style="padding: 0.25rem 0.5rem;">
                        Download
                      </button>
                    </div>
                    <div class="text-xs text-gray-500">
                      <div>Size: ${Math.round(snippet.width)} √ó ${Math.round(snippet.height)}px</div>
                    </div>
                  </div>
                `;
                }).join('')}
              </div>
            `;
          } else {
            // Render regular snippet
            const { snippet, index } = group;
            const isHighlighted = highlightedSnippet === index;
            return `
              <div class="snippet-item" onclick="highlightSnippet(${index})" style="cursor: pointer; ${isHighlighted ? 'border-color: #3b82f6; background: #eff6ff;' : ''}">
                <div class="flex items-center justify-between mb-2">
                  <span style="font-weight: 500">Snippet ${index + 1}</span>
                  <div class="flex gap-2">
                    <button onclick="event.stopPropagation(); downloadSnippet(${index})" class="btn btn-sm btn-primary">
                      Download
                    </button>
                    <button onclick="event.stopPropagation(); deleteSnippet(${snippet.id})" class="btn btn-sm btn-red">
                      Delete
                    </button>
                  </div>
                </div>
                <div class="flex gap-2 mb-2">
                  <button onclick="event.stopPropagation(); splitSnippetHorizontally(${index}, 2)" class="btn btn-sm btn-light-blue" style="flex: 1; font-size: 0.7rem;">
                    ‚Üî Split into 2
                  </button>
                  <button onclick="event.stopPropagation(); splitSnippetHorizontally(${index}, 3)" class="btn btn-sm btn-light-blue" style="flex: 1; font-size: 0.7rem;">
                    ‚Üî Split into 3
                  </button>
                </div>
                <div class="text-xs text-gray-500">
                  <div>Size: ${Math.round(snippet.width)} √ó ${Math.round(snippet.height)}px</div>
                </div>
              </div>
            `;
          }
        }).join('');
      }
    }

    function highlightSnippet(index) {
      if (highlightedSnippet === index) {
        // Click again to unhighlight
        highlightedSnippet = -1;
      } else {
        highlightedSnippet = index;
      }
      updateCanvas();
      updateSnippetList();
    }

    function downloadSnippet(index) {
      const snippet = snippets[index];
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = snippet.width;
      tempCanvas.height = snippet.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(
        image,
        snippet.x, snippet.y, snippet.width, snippet.height,
        0, 0, snippet.width, snippet.height
      );
      
      // Generate proper file name
      let fileName;
      if (snippet.parentId) {
        // For split snippets, use parent label and position
        const parentNum = snippet.parentLabel.replace('Snippet ', '');
        fileName = `snippet-${parentNum}-${snippet.position.toLowerCase()}`;
      } else {
        // For regular snippets, count only non-split snippets before this one
        let regularSnippetNum = 1;
        for (let i = 0; i < index; i++) {
          if (!snippets[i].parentId) {
            regularSnippetNum++;
          }
        }
        fileName = `snippet-${regularSnippetNum}`;
      }
      
      // Use compression if enabled
      if (useCompression) {
        // Convert to JPEG with quality setting for better compression
        tempCanvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${fileName}.jpg`;
          a.click();
          URL.revokeObjectURL(url);
        }, 'image/jpeg', compressionQuality);
      } else {
        // Use PNG without compression
        tempCanvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${fileName}.png`;
          a.click();
          URL.revokeObjectURL(url);
        }, 'image/png');
      }
    }

    function deleteSnippet(id) {
      const snippetToDelete = snippets.find(s => s.id === id);
      
      if (snippetToDelete && snippetToDelete.parentId) {
        // If deleting a child snippet, delete all siblings too
        const parentId = snippetToDelete.parentId;
        snippets = snippets.filter(s => s.parentId !== parentId);
      } else {
        // Delete single snippet
        snippets = snippets.filter(s => s.id !== id);
      }
      
      highlightedSnippet = -1; // Reset highlight
      updateCanvas();
      updateSnippetList();
      saveState();
    }

    function splitSnippetHorizontally(index, numColumns) {
      const snippet = snippets[index];
      
      // Don't allow splitting if this is already a child snippet
      if (snippet.parentId) {
        alert('This snippet has already been split and cannot be split again.');
        return;
      }
      
      const columnWidth = snippet.width / numColumns;
      const newSnippets = [];
      const labels = numColumns === 2 ? ['Left', 'Right'] : ['Left', 'Center', 'Right'];
      
      // Create new snippets for each column
      for (let i = 0; i < numColumns; i++) {
        newSnippets.push({
          id: Date.now() + i,
          x: snippet.x + (i * columnWidth),
          y: snippet.y,
          width: columnWidth,
          height: snippet.height,
          parentId: snippet.id,
          parentLabel: `Snippet ${index + 1}`,
          position: labels[i]
        });
      }
      
      // Mark the original snippet as a parent (split)
      snippet.isSplit = true;
      snippet.children = newSnippets.map(s => s.id);
      
      // Remove the original snippet and insert new ones
      snippets.splice(index, 1, ...newSnippets);
      updateCanvas();
      updateSnippetList();
      saveState();
    }

    function downloadAll() {
      snippets.forEach((snippet, index) => {
        setTimeout(() => downloadSnippet(index), index * 500);
      });
    }

    function downloadGroup(firstChildId) {
      const firstChild = snippets.find(s => s.id === firstChildId);
      if (!firstChild) return;
      
      const groupSnippets = snippets.filter(s => s.parentId === firstChild.parentId);
      groupSnippets.forEach((snippet, i) => {
        const index = snippets.indexOf(snippet);
        setTimeout(() => downloadSnippet(index), i * 500);
      });
    }
  </script>
</body>
</html>